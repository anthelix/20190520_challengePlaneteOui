{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Worflow](workflow3.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "    1_Define Problem\n",
    "    2_Specify Inputs & Outputs\n",
    "    3_Exploratory data analysis\n",
    "    4_Data Collection\n",
    "    5_Data Preprocessing\n",
    "    6_Data Cleaning\n",
    "    7_Visualization\n",
    "    8_Model Design, Training, and Offline Evaluation\n",
    "    9_Model Deployment, Online Evaluation, and Monitoring\n",
    "    10_Model Maintenance, Diagnosis, and Retraining\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1_DEFINE PROBLEM"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Description informelle\n",
    "\n",
    "    je veux ecrire un programme capable de predire la consommation electrique pour une annee d'essai"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Formalisme selon Tom Mitchell\n",
    "\n",
    "    Tache (T): Estimer la consomation electrique\n",
    "\n",
    "    Performance(P): la precision de la prediction faite par l'algorithme et a quel point elle est proche de la              consomation reelle (loc_secondary).\n",
    "\n",
    "    Experience(E): la temperature, l'humidite et la consommation reelle, les dates"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Benefice attendu: \n",
    "\n",
    "    apprendre sur les donnees manquantes, sur la gestion de glissement de date, apprentissage semi-supervise"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* How does your company expact to use and benfit from your model.\n",
    "\n",
    "    In operational conditions, the new consumption profiles would be integrated to electricity supply pricing analysis. \n",
    "    \n",
    "    BCM Energy is a start-up based in Lyon and created in 2015. BCM operates on the whole value chain of renewable electricity, from production assets management on electricity markets (Epexspot, EEX) to electricity supply to final consumers through the brand Planète OUI.\n",
    "    \n",
    "    Planète OUI, created in 2007, is one of the first French green electricity supplier. The company supplies tens of thousands of homes and professionals and covers more than 95 % of metropolitan France (Enedis network). Planète OUI promotes an ecology constructive and made available for all. It has integrated BCM Energy’s perimeter in 2017.\n",
    "    \n",
    "    Planete OUI has to offer green electricity supply with prices adapted to the consumption profiles of its clients. The electricity is indeed bough on the electricity markets, where prices are highly variable during a day.\n",
    "   \n",
    "    A site with a high share of consumption when prices are low, for example at mid-afternoon, will be supplied at lower costs than a site consuming electricity mainly during peak price intervals. The consumption profile of an installation has then to be appraised to compute the best estimation of supply tariffs, allowing Planète OUI to meet its running costs while supplying its client at the best price.\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2_Specify Inputs & Outputs"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**donnees utiles pour predire une consomation electrique**\n",
    "    * humidite,\n",
    "    * Temperature,\n",
    "    * Moyenne Nationale de Temperature,\n",
    "    * Jour de la semaine,\n",
    "    * Periode de l'annees,\n",
    "**recuperer ces donnees**\n",
    "    * API externes, \n",
    "    * beses de donnnes,\n",
    "    * openDara\n",
    "    * donnees d'entreprises"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Problem Fetures**\n",
    "\n",
    "This data set contains information about 13 features\n",
    "* ID\n",
    "* timestamp\n",
    "* temp_1\n",
    "* temp_2\n",
    "* mean_national_temp\n",
    "* humidity_1\n",
    "* humidity_2\n",
    "* loc_1\n",
    "* loc_2\n",
    "* loc_secondary_1\n",
    "* loc_secondary_2\n",
    "* loc_secondary_3\n",
    "* consumption_secondary_1\n",
    "* consumption_secondary_2\n",
    "* consumption_secondary_3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Aim**\n",
    "\n",
    "The job is to predict the consumption of loc_1 and loc_2. For each ID in the test set, I must predict a Kwh value for the consumption1 and the consumption2 variables"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Variable**\n",
    "\n",
    "* ID: ID du point de donnees (site)\n",
    "    - have no impact on the outcome variable. Thus, it will be exclued fron analysis\n",
    "* timestamp: Horodatage complet avec annee, mois, jour et heure (en heure local CET et CEST)\n",
    "    - 1 heure entre chaque timestamp\n",
    "    - format datastring then i must define the input format, use it to parse the original string then define the output format and use it to convrt it back. \\df['Date'] = df['Date'].astype('datetime64[ns]')\\df_train['datetime'] = pd.to_datetime(df_train['datetime'])\\\n",
    "    - format in the data set : 2016-11-01T00:00:00.0,T separateur date heure\n",
    "    - http://icalendrier.fr/calendriers-saga/etudes-thematiques/iso-8601\n",
    "* temp_1: Temperatures locales en °C \n",
    "    - it could be used in feature enginnering with the mean and the humidity1\n",
    "* temp_2: Temperatures locales en °C\n",
    "    -     - it could be used in feature enginnering with the mean and the humidity2\n",
    "* mean_national_temp: Moyenne des temperatures nationales en C\n",
    "    - it could be used in feature enginnering with the T1° and T1° and the humidity1 and humidity2\n",
    "* humidity_1: Humidité relative locale (%)\n",
    "    - it could be used in feature enginnering with the T1° and the mean T°\n",
    "* humidity_2: Humidité relative locale (%)\n",
    "    - it could be used in feature enginnering with the T2° and the mean T°\n",
    "* loc_1: Coordonnees des sites etudies en degres decimaux et de la forme (latitude, longitude)\n",
    "    - string, nominal datatype\n",
    "    - use it on a map\n",
    "* loc_2: Coordonnees des sites etudies en degres decimaux et de la forme (latitude, longitude)\n",
    "    - string,, nominal datatype, \n",
    "    - use it on a map\n",
    "* loc_secondary_1: Coordonnees des sites secondaires en degres decimaux et de la forme (latitude, longitude)\n",
    "    - string, , nominal datatype,\n",
    "    - use it on a map\n",
    "    - it could be used in feature engineering to compare at loc 1 and loc 2\n",
    "* loc_secondary_2: Coordonnees des sites secondaires en degres decimaux et de la forme (latitude, longitude)\n",
    "    - string, , nominal datatype, \n",
    "    - it could be used in feature engineering to compare at loc 1 and loc 2\n",
    "    - use it on a map\n",
    "* loc_secondary_3: Coordonnees des sites secondaires en degres decimaux et de la forme (latitude, longitude)\n",
    "    - string, , nominal datatype, \n",
    "    - it could be used in feature engineering to compare at loc 1 and loc 2\n",
    "    - use it on a map \n",
    "* consumption_secondary_1: kWh) donnees de consommation de 3 sites secondaires dont les correlations avec les sites etudiees peubvent etre utiles\n",
    "    - to estimate the consumption\n",
    "* consumption_secondary_2: (kWh) donnees de consommation de 3 sites secondaires dont les correlations avec les sites etudiees peubvent etre utiles\n",
    "    - to estimate the consumption\n",
    "* consumption_secondary_3: (kWh) donnees de consommation de 3 sites secondaires dont les correlations avec les sites etudiees peubvent etre utiles\n",
    "    - to estimate the consumption"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Types of Features**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*Categorical*\n",
    "    - Une variable catégorielle est une variable qui a deux catégories ou plus et chaque valeur de cette caractéristique peut être catégorisée par elles. Par exemple, le sexe est une variable catégorielle ayant deux catégories (homme et femme). Maintenant, nous ne pouvons pas trier ou donner d'ordre à de telles variables. Elles sont également connues sous le nom de variables nominales. Elles mesurent des etats, il n'y a pas d'echelle de valeurs. \n",
    "    - loc_1, loc_2, loc_secondary_2, loc_secondary_1, loc_secondary_3,"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*Ordinal*\n",
    "    - Une variable ordinale est similaire aux valeurs catégorielles, mais la différence entre elles est que nous pouvons avoir un ordre ou un tri relatif entre les valeurs. Par exemple : Si nous avons une fonction comme Hauteur avec des valeurs Tall, Medium, Short, alors Hauteur est une variable ordinale. Ici nous pouvons avoir un tri relatif dans la variable.\n",
    "    - timestamp, "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*Continous*\n",
    "    - A feature is said to be continous if it can take values between any two points or between the minimum or maximum values in the features column. \n",
    "    - temp_1, temp_2, mean_national_temp, humidity_1, humidity_2, consumption_secondary_1, consumption_secondary_2, consumption_secondary_3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Inputs & Outputs**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*Inputs*\n",
    "- input_test_cdKcI0e.csv\n",
    "- input_training_ssnsrY0.csv\n",
    "- output_training_Uf11I9I.csv\n",
    "\n",
    "*Ouputs*\n",
    "- My score is the consumption for each loc correctly predict, the accuracy\n",
    "- The output should have exactly 3 columns:\n",
    "        - ID(sorted in order)\n",
    "        - consumption_loc_1(contains value in Kwh)\n",
    "        - consumption_loc_2(contains value in Kwh)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3_Select Framework"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Import**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np # linear algebra\n",
    "import pandas as pd # data processing, CSV file\n",
    "import os # Le module d'OS en Python fournit un moyen d'utiliser les fonctionnalités dépendantes du système d'exploitation. \n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import matplotlib.pylab as pylab\n",
    "import warnings\n",
    "import matplotlib as mpl\n",
    "import datetime as dt\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**better code readability**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sns.set(style='white', context='notebook', palette='deep')\n",
    "pylab.rcParams['figure.figsize'] = 12,8\n",
    "warnings.filterwarnings('ignore')\n",
    "mpl.style.use('ggplot')\n",
    "sns.set_style('white')\n",
    "%matplotlib inline\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I use Jupyter Notebook for my notes and spyder for the data work. and I can use JN on iMac but not spyder"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4_Exploratory Data Analysis(EDA)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**1-Data Collection**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "La collecte de données est le processus de collecte et de mesure de données, d'informations ou de toute variable d'intérêt d'une manière normalisée et établie qui permet au collecteur de répondre ou de tester des hypothèses et d'évaluer les résultats de la collecte particulière[techopedia].\n",
    "Je commence la collecte des données par la formation et le test des ensembles de données dans Pandas DataFrames."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rawData_trainInput = pd.read_csv('data_set1/input_training_ssnsrY0.csv')\n",
    "rawData_trainOutput = pd.read_csv('data_set1/output_training_Uf11I9I.csv')\n",
    "rawData_testInput = pd.read_csv('data_set1/input_test_cdKcI0e.csv')\n",
    "trainInput = rawData_trainInput.copy(deep=True)\n",
    "trainOutput = rawData_trainOutput.copy(deep=True)\n",
    "testInput = rawData_testInput.copy(deep=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('Train Input is:', trainInput.shape)\n",
    "print('Train Output is:',trainOutput.shape)\n",
    "print('Test Input is:',testInput.shape)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(trainInput.head(2))\n",
    "print('----------------------------------------------------------\\n')\n",
    "print(testInput.head(2))\n",
    "print('----------------------------------------------------------\\n')\n",
    "print(trainOutput.head(2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(trainInput.dtypes)\n",
    "print('----------------------------------------------------------\\n')\n",
    "print(testInput.dtypes)\n",
    "print('----------------------------------------------------------\\n')\n",
    "print(trainOutput.dtypes)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"TrainInput:\\n\", trainInput.isnull().sum())\n",
    "print('-'*10)\n",
    "print(\"TestInput:\\n\", testInput.isnull().sum())    \n",
    "print('-'*10)\n",
    "print(\"TrainOutput:\\n\", trainOutput.isnull().sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('coordonnees loc_1:', trainInput['loc_1'][1], testInput['loc_1'][1])\n",
    "print('coordonnees loc_2:',trainInput['loc_2'][1], trainInput['loc_2'][1])\n",
    "print('coordonnees loc_secondary_1:',trainInput['loc_secondary_1'][1], trainInput['loc_secondary_1'][1])\n",
    "print('coordonnees loc_secondary_2:',trainInput['loc_secondary_2'][1], trainInput['loc_secondary_2'][1])\n",
    "print('coordonnees loc_secondary_3:',trainInput['loc_secondary_3'][1], trainInput['loc_secondary_3'][1])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Map des 5 points](map.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**2-Visualization**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(trainInput['timestamp'], trainInput['temp_1'])\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig = plt.fig(figsize=(12,6))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "loc = ['loc_1', 'loc_2']\n",
    "loc_secondary = ['loc_secondary_1', 'loc_secondary_2', 'loc_secondary_3']\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
